SQL vs NOSQL

NOSQL :
NoSQL main benefit is the data can be stored in any structure there is no specific relationships between entities
In SQL there are specific relation ship so in case we need to migrate the whole data model it is very tough, In Nosql since there are no relations between the entities 
we can remodel as need.

horizontal scaling is available in nosql but in sql vertical scaling is main oprion

scaling and storing huge data in mongo db is chepaer and easy to maintian, sql db is costly

Nosql is not good enough when there needs to be huge reporting and dataminig queries are very advanced as there are no specific relationship between entities

ACID is supported by mongo but not by all other no sql DBS, however over multi document transaction max time is 15 second
so in cases when millions of data inserted within same transactionn NOSQL is not good enough

benefits of sql
in case data model is fixed and stable we cna use SQL
in case transaction suport is needed for more than15 second or huge amount we can go for sql
however it is tough to modify and upgrade db model as relationships are present
vertical scaling is costly
Better ACID support


Similiar terms:

Database/schema   ->  Database
Table     ->    Collection
Rows      ->    Document
Columns    ->    Field
Indexex   - > Indexes

commadn to connect to mongo db
mongodb+srv://kbhatt23:Suarez@23@localhost:27017

Difference btween insert method and save method of mongoRepository/mongoTemplate
insert -> if id is missing that a new document is created in colection with autogenerated value for id
	   -> if id is present
	   					-> if id do not exist in DB then it creates a new document with that id mentioned
	   					-> if id exist in DB an exceptionw tih duplicatiokecyfound excpetion is thrown
	   					
save- > if id is missing that a new document is created in colection with autogenerated value for id
      -> if id is present
                        -> if id do not exist in DB then it creates a new document with that id mentioned
	   					-> if id exist in DB it overrides the other fields of document with the same id and a new document is not inserted in db
	   					
In mongo DB if id is given the same id can be used to insert otherwise autogenrated id is used

spring data JPA respository method composition can handle lot of scenarios however
in scenario like we want to query on bassis on embeded document property or embedded array document filed we need @query

method composition is declarative but @query is imperative as we have do tell api how to do but in declarative we just tell what we want
,and framework will work on implementation

Sorting can be needed in 3 scenarios:
a . methods out of the box presented in mongorepostiry interface :
Just add sort object and pass from service class and proxy will use it as oob methods also have 
overloadded methods containsing sort

b. methods created by us:
Add another method argument as Sort and pass it from service class
proxy will add this logic on its own

c. methods containsing @query 
We need to add sort by or oder by condition in query

Query DSL can be used to replace @query annotation in mongoRepository
This can handle complex scenrios of filtering and also in case field values in mongo db is changed we hve to modify at all places

Using Query DSL we can add complex predicates and extend QueryDSLrepostiory at the @repository interface and then each method will get overloaded
methods with Predicates

Code changes:
step1 : add dependecy for apt-query-dsl
step2 : add maven build tag for query dsl : when we do clan packge all @documents will get scanned and its own queryDSL classes will get generated

We can create predicates using these class generated in target folder

MongoTempalte is similar to mongoReepository but it is more suited when more complex scenarios comes part from data CRUD and filtering
For example advance filtering can be done using QueryDSL in mongoREpsoitory
but when reporting and data projection is needed in mongo db collection then we can use mongoTempalte

Data projection is way of extracting real content in mongo collections and conerting into another model whihc is better suited for reporting
Very advanced Business intelligence reposrting is not suited for NOSQL
but basic ones can be done using data projection using aggregate method in mongo template 

Mongo template can not create indexes on its own
MongoRepository can do it : just using insert method it creates index for properpties annotated with @indexed

so mongorepostiory should be sued in inserting scenarios
in advanced filterting and search we can use mongoRepsository
but for advanced reporting and data projection we should use mongotempalte

===Full Text Search==
A full text search can give input to any string and this tring can be value of any n number of fields or properties of document
we can get list of documents back for whome the whole string input is present as value of any number(fixed) field values



====data migration===
3 scenarios of change in data structure in mongodb
a. create a new collection : automaticall on server startup new collection will get created
	with no issue with existing collections
b. create new field in existing collection : In this case for older documents
	the newly added field will be null, however spring data jpa will deserialize it to
	default java value(0 for int, null for stirng and object etc)
	and this value will be visible in api response, however better way is to use mongo bee
	to migrate the older data in mongo db with some default value for null values of new field.
	This will make DB in sync with application using data jpa
c. Modify the property name : This will make the value to show null in api
	as deserializer will use new property to fetch and that will not be present in mongo db
	also queries will stop working. we shud not do it as best practise
	
Mongo BEE steps :
a. add pom.xml depndency
b. Create @bean for mongobeerunner -> add packages to scan etc
c. Create @changeLog annottaed class in previously defined package, 
 we can add order for all these classes to introduce execution order of change log classes
 d. Create method wtih @changeset and injectMongotemplate to wrrite criteria query
 	to fetch null entries and update all in bulk with default value
 	e. start the application
	